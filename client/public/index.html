<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="Web site created using create-react-app" />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>BZ Plan</title>

    <link rel="stylesheet" href="%PUBLIC_URL%/css/classic.min.css">
    <link rel="stylesheet" href="%PUBLIC_URL%/css/nano.min.css">

    <link rel="stylesheet" href="%PUBLIC_URL%/dist/plugins/font-awesome/css/all.css">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">

    <link rel="stylesheet" href="%PUBLIC_URL%/editor/style.css">


    <style>
        @font-face {
            font-family: "Poppins";
            src: url("%PUBLIC_URL%/fonts/Poppins Regular.ttf");
        }
    </style>

    <style type="text/css">
        svg:not(:root).svg-inline--fa {
            overflow: visible
        }

        .svg-inline--fa {
            display: inline-block;
            font-size: inherit;
            height: 1em;
            overflow: visible;
            vertical-align: -.125em
        }

        .svg-inline--fa.fa-lg {
            vertical-align: -.225em
        }

        .svg-inline--fa.fa-w-1 {
            width: .0625em
        }

        .svg-inline--fa.fa-w-2 {
            width: .125em
        }

        .svg-inline--fa.fa-w-3 {
            width: .1875em
        }

        .svg-inline--fa.fa-w-4 {
            width: .25em
        }

        .svg-inline--fa.fa-w-5 {
            width: .3125em
        }

        .svg-inline--fa.fa-w-6 {
            width: .375em
        }

        .svg-inline--fa.fa-w-7 {
            width: .4375em
        }

        .svg-inline--fa.fa-w-8 {
            width: .5em
        }

        .svg-inline--fa.fa-w-9 {
            width: .5625em
        }

        .svg-inline--fa.fa-w-10 {
            width: .625em
        }

        .svg-inline--fa.fa-w-11 {
            width: .6875em
        }

        .svg-inline--fa.fa-w-12 {
            width: .75em
        }

        .svg-inline--fa.fa-w-13 {
            width: .8125em
        }

        .svg-inline--fa.fa-w-14 {
            width: .875em
        }

        .svg-inline--fa.fa-w-15 {
            width: .9375em
        }

        .svg-inline--fa.fa-w-16 {
            width: 1em
        }

        .svg-inline--fa.fa-w-17 {
            width: 1.0625em
        }

        .svg-inline--fa.fa-w-18 {
            width: 1.125em
        }

        .svg-inline--fa.fa-w-19 {
            width: 1.1875em
        }

        .svg-inline--fa.fa-w-20 {
            width: 1.25em
        }

        .svg-inline--fa.fa-pull-left {
            margin-right: .3em;
            width: auto
        }

        .svg-inline--fa.fa-pull-right {
            margin-left: .3em;
            width: auto
        }

        .svg-inline--fa.fa-border {
            height: 1.5em
        }

        .svg-inline--fa.fa-li {
            width: 2em
        }

        .svg-inline--fa.fa-fw {
            width: 1.25em
        }

        .fa-layers svg.svg-inline--fa {
            bottom: 0;
            left: 0;
            margin: auto;
            position: absolute;
            right: 0;
            top: 0
        }

        .fa-layers {
            display: inline-block;
            height: 1em;
            position: relative;
            text-align: center;
            vertical-align: -.125em;
            width: 1em
        }

        .fa-layers svg.svg-inline--fa {
            -webkit-transform-origin: center center;
            transform-origin: center center
        }

        .fa-layers-counter,
        .fa-layers-text {
            display: inline-block;
            position: absolute;
            text-align: center
        }

        .fa-layers-text {
            left: 50%;
            top: 50%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
            -webkit-transform-origin: center center;
            transform-origin: center center
        }

        .fa-layers-counter {
            background-color: #ff253a;
            border-radius: 1em;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            color: #fff;
            height: 1.5em;
            line-height: 1;
            max-width: 5em;
            min-width: 1.5em;
            overflow: hidden;
            padding: .25em;
            right: 0;
            text-overflow: ellipsis;
            top: 0;
            -webkit-transform: scale(.25);
            transform: scale(.25);
            -webkit-transform-origin: top right;
            transform-origin: top right
        }

        .fa-layers-bottom-right {
            bottom: 0;
            right: 0;
            top: auto;
            -webkit-transform: scale(.25);
            transform: scale(.25);
            -webkit-transform-origin: bottom right;
            transform-origin: bottom right
        }

        .fa-layers-bottom-left {
            bottom: 0;
            left: 0;
            right: auto;
            top: auto;
            -webkit-transform: scale(.25);
            transform: scale(.25);
            -webkit-transform-origin: bottom left;
            transform-origin: bottom left
        }

        .fa-layers-top-right {
            right: 0;
            top: 0;
            -webkit-transform: scale(.25);
            transform: scale(.25);
            -webkit-transform-origin: top right;
            transform-origin: top right
        }

        .fa-layers-top-left {
            left: 0;
            right: auto;
            top: 0;
            -webkit-transform: scale(.25);
            transform: scale(.25);
            -webkit-transform-origin: top left;
            transform-origin: top left
        }

        .fa-lg {
            font-size: 1.33333em;
            line-height: .75em;
            vertical-align: -.0667em
        }

        .fa-xs {
            font-size: .75em
        }

        .fa-sm {
            font-size: .875em
        }

        .fa-1x {
            font-size: 1em
        }

        .fa-2x {
            font-size: 2em
        }

        .fa-3x {
            font-size: 3em
        }

        .fa-4x {
            font-size: 4em
        }

        .fa-5x {
            font-size: 5em
        }

        .fa-6x {
            font-size: 6em
        }

        .fa-7x {
            font-size: 7em
        }

        .fa-8x {
            font-size: 8em
        }

        .fa-9x {
            font-size: 9em
        }

        .fa-10x {
            font-size: 10em
        }

        .fa-fw {
            text-align: center;
            width: 1.25em
        }

        .fa-ul {
            list-style-type: none;
            margin-left: 2.5em;
            padding-left: 0
        }

        .fa-ul>li {
            position: relative
        }

        .fa-li {
            left: -2em;
            position: absolute;
            text-align: center;
            width: 2em;
            line-height: inherit
        }

        .fa-border {
            border: solid .08em #eee;
            border-radius: .1em;
            padding: .2em .25em .15em
        }

        .fa-pull-left {
            float: left
        }

        .fa-pull-right {
            float: right
        }

        .fa.fa-pull-left,
        .fab.fa-pull-left,
        .fal.fa-pull-left,
        .far.fa-pull-left,
        .fas.fa-pull-left {
            margin-right: .3em
        }

        .fa.fa-pull-right,
        .fab.fa-pull-right,
        .fal.fa-pull-right,
        .far.fa-pull-right,
        .fas.fa-pull-right {
            margin-left: .3em
        }

        .fa-spin {
            -webkit-animation: fa-spin 2s infinite linear;
            animation: fa-spin 2s infinite linear
        }

        .fa-pulse {
            -webkit-animation: fa-spin 1s infinite steps(8);
            animation: fa-spin 1s infinite steps(8)
        }

        @-webkit-keyframes fa-spin {
            0% {
                -webkit-transform: rotate(0);
                transform: rotate(0)
            }

            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg)
            }
        }

        @keyframes fa-spin {
            0% {
                -webkit-transform: rotate(0);
                transform: rotate(0)
            }

            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg)
            }
        }

        .fa-rotate-90 {
            -webkit-transform: rotate(90deg);
            transform: rotate(90deg)
        }

        .fa-rotate-180 {
            -webkit-transform: rotate(180deg);
            transform: rotate(180deg)
        }

        .fa-rotate-270 {
            -webkit-transform: rotate(270deg);
            transform: rotate(270deg)
        }

        .fa-flip-horizontal {
            -webkit-transform: scale(-1, 1);
            transform: scale(-1, 1)
        }

        .fa-flip-vertical {
            -webkit-transform: scale(1, -1);
            transform: scale(1, -1)
        }

        .fa-flip-horizontal.fa-flip-vertical {
            -webkit-transform: scale(-1, -1);
            transform: scale(-1, -1)
        }

        :root .fa-flip-horizontal,
        :root .fa-flip-vertical,
        :root .fa-rotate-180,
        :root .fa-rotate-270,
        :root .fa-rotate-90 {
            -webkit-filter: none;
            filter: none
        }

        .fa-stack {
            display: inline-block;
            height: 2em;
            position: relative;
            width: 2em
        }

        .fa-stack-1x,
        .fa-stack-2x {
            bottom: 0;
            left: 0;
            margin: auto;
            position: absolute;
            right: 0;
            top: 0
        }

        .svg-inline--fa.fa-stack-1x {
            height: 1em;
            width: 1em
        }

        .svg-inline--fa.fa-stack-2x {
            height: 2em;
            width: 2em
        }

        .fa-inverse {
            color: #fff
        }

        .sr-only {
            border: 0;
            clip: rect(0, 0, 0, 0);
            height: 1px;
            margin: -1px;
            overflow: hidden;
            padding: 0;
            position: absolute;
            width: 1px
        }

        .sr-only-focusable:active,
        .sr-only-focusable:focus {
            clip: auto;
            height: auto;
            margin: 0;
            overflow: visible;
            position: static;
            width: auto
        }
    </style>

    <style>
        /*
        DEMO STYLE
    */


        body {
            font-family: "Poppins";
            background: #fafafa;
        }

        p {
            font-family: "Poppins";
            font-size: 1.1em;
            font-weight: 300;
            line-height: 1.7em;
            color: #999;
        }

        a,
        a:hover,
        a:focus {
            color: inherit;
            text-decoration: none;
            transition: all 0.3s;
        }

        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 999;
            padding: 15px 10px;
            background: #fff;
            border: none;
            border-radius: 0;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
        }

        .navbar-btn {
            box-shadow: none;
            outline: none !important;
            border: none;
        }

        .line {
            width: 100%;
            height: 1px;
            border-bottom: 1px dashed #ddd;
            margin: 40px 0;
        }

        /* ---------------------------------------------------
        SIDEBAR STYLE
        ----------------------------------------------------- */

        .wrapper {
            display: flex;
            width: 100%;
        }


        #sidebar {
            position: fixed;
            top: 60px;
            left: 0;
            height: 100vh;
            min-width: 250px;
            max-width: 250px;
            color: #fff;
            transition: all 0.6s cubic-bezier(0.945, 0.020, 0.270, 0.665);
            transform-origin: bottom left;
            z-index: 999;
            overflow: auto;
        }

        #sidebar.active {
            margin-left: -250px;
            /* transform: rotateY(100deg); */
        }

        #sidebar .sidebar-header {
            padding: 20px;
        }

        #sidebar ul.components {
            padding: 20px 0;
            border-bottom: 1px solid #4b4b4b;
        }

        #sidebar ul p {
            color: #fff;
            padding: 10px;
        }

        #sidebar ul li a {
            padding: 6px 15px;
            font-size: 1.1em;
            display: block;
            margin-bottom: 5px;
            border-radius: 4px;
        }

        #sidebar ul li a:hover {
            color: #ffffff;
            background: #646464;
            border-radius: 4px;
        }

        #sidebar ul li.active>a,
        a[aria-expanded="true"] {
            color: #fff;
        }


        a[data-toggle="collapse"] {
            position: relative;
        }

        .dropdown-toggle::after {
            display: block;
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
        }

        ul ul a {
            font-size: 0.9em !important;
            padding-left: 30px !important;
        }

        ul.CTAs {
            padding: 20px;
        }

        ul.CTAs a {
            text-align: center;
            font-size: 0.9em !important;
            display: block;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        a.download {
            background: #fff;
        }

        a.article,
        a.article:hover {
            color: #fff !important;
        }

        #floorpanSubmenu li a img {
            margin-right: 10px;
        }


        /* ---------------------------------------------------
        CONTENT STYLE
        ----------------------------------------------------- */

        #content {
            width: 100%;
            margin-top: 100px;
            margin-left: 250px;
            margin-bottom: 50px;
            min-height: 100%;
            transition: all 0.3s;
            padding: 20px;
        }

        #sidebarCollapse {
            width: 40px;
            height: 40px;
            background-color: transparent;
            cursor: pointer;
        }

        #sidebarCollapse span {
            width: 80%;
            height: 2px;
            margin: 0 auto;
            display: block;
            background: #ffffff;
            transition: all 0.8s cubic-bezier(0.810, -0.330, 0.345, 1.375);
            transition-delay: 0.2s;
        }

        #sidebarCollapse span:first-of-type {
            transform: rotate(45deg) translate(2px, 2px);
        }

        #sidebarCollapse span:nth-of-type(2) {
            opacity: 0;
        }

        #sidebarCollapse span:last-of-type {
            transform: rotate(-45deg) translate(1px, -1px);
        }


        #sidebarCollapse.active span {
            transform: none;
            opacity: 1;
            margin: 5px auto;
        }


        /* ---------------------------------------------------
        MEDIAQUERIES
        ----------------------------------------------------- */

        @media (max-width: 768px) {
            #content {
                margin-left: 0 !important;
            }
        }

        .btn-custom {
            width: 100px;
            border-radius: 99px !important;
            padding: 10px 20px !important;
            font-weight: 600 !important;
            outline: none;
            user-select: none;
            border: 0;
            box-shadow: none !important;
        }

        .btn-change {
            background-color: #ffc107;
            color: #fff;
        }

        .btn-custom:hover {
            color: #fff;
        }

        button:active {
            outline: none;
            border: none;
        }

        button:focus {
            outline: none;
            border: none;
        }

        .btn:focus {
            outline: 0;
            box-shadow: none;
        }

        .btn-status {
            width: 56px;
        }

        .btn-primary {
            background-color: #66cc99 !important;
        }

        .btn-danger {
            background-color: #e45f55 !important;
            border: 1px solid #e45f55 !important;
        }

        .btn-color-data {
            background-color: #3f51b5 !important;
            border: 1px solid #3f51b5 !important;
            color: #fff;
        }

        .btn-color-data:hover {
            color: #fff;
        }

        .modal-header {
            border: 0 !important;

        }

        .modal-footer {
            border: 0 !important;
            padding-top: 0 !important;
        }

        table {
            border-top: 1px solid #e6e6e6;
        }

        table tr {
            border-bottom: 1px solid #e6e6e6;
        }

        table th {
            padding: 0.75rem;
        }

        table td {
            padding: 0.75rem;
        }
    </style>

</head>

<body>
    <div id="root"></div>

    <!-- <script src="%PUBLIC_URL%/editor/hammer.min.js"></script>
    <script src="%PUBLIC_URL%/editor/viewer.js"></script>

    <script>
        window.Viewer = Viewer;
    </script> -->

    <script src="%PUBLIC_URL%/js/pickr.min.js"></script>

    <script src="%PUBLIC_URL%/js/jquery/jquery.min.js"></script>
    <script src="%PUBLIC_URL%/js/svg/grid.js"></script>
    <script src="%PUBLIC_URL%/js/svg/svg-pan-zoom.js"></script>

    <script src="%PUBLIC_URL%/js/svg/svgo.browser.js"></script>
    <script src="%PUBLIC_URL%/js/svg/svg-path-commander.js"></script>
    <script src="%PUBLIC_URL%/js/svg/svgdotjs.js"></script>
    <script src="%PUBLIC_URL%/js/svg/path-data-polyfill.js"></script>
    <script src="%PUBLIC_URL%/js/svg/toPoly.js"></script>

    <script src="%PUBLIC_URL%/js/svg-pan-zoom.js"></script>

    <script>
        var svgo = new SVGO();
    </script>

    <script src="%PUBLIC_URL%/js/three/three.js"></script>
    <script src="%PUBLIC_URL%/js/three/camera-controls.js"></script>
    <script src="%PUBLIC_URL%/js/three/GLTFLoader.js"></script>
    <script src="%PUBLIC_URL%/js/three/GLTFExporter.js"></script>
    <script src="%PUBLIC_URL%/js/three/RoomEnvironment.js"></script>
    <script>

        function createSVGElement(name) {
            var element = document.createElementNS("http://www.w3.org/2000/svg", name);
            return element;
        }

        function createSVGMatrix() {
            return createSVGElement("svg").createSVGMatrix();
        }


        function decompose(matrix, cx = 0, cy = 0) {
            // Get the parameters from the matrix
            const a = matrix.a
            const b = matrix.b
            const c = matrix.c
            const d = matrix.d
            const e = matrix.e
            const f = matrix.f

            // Figure out if the winding direction is clockwise or counterclockwise
            const determinant = a * d - b * c
            const ccw = determinant > 0 ? 1 : -1

            // Since we only shear in x, we can use the x basis to get the x scale
            // and the rotation of the resulting matrix
            const sx = ccw * Math.sqrt(a * a + b * b)
            const thetaRad = Math.atan2(ccw * b, ccw * a)
            const theta = (180 / Math.PI) * thetaRad
            const ct = Math.cos(thetaRad)
            const st = Math.sin(thetaRad)

            // We can then solve the y basis vector simultaneously to get the other
            // two affine parameters directly from these parameters
            const lam = (a * c + b * d) / determinant
            const sy = (c * sx) / (lam * a - b) || (d * sx) / (lam * b + a)

            // Use the translations
            const tx = e - cx + cx * ct * sx + cy * (lam * ct * sx - st * sy)
            const ty = f - cy + cx * st * sx + cy * (lam * st * sx + ct * sy)

            // Construct the decomposition and return it
            return {
                // Return the affine parameters
                scaleX: sx,
                scaleY: sy,
                shear: lam,
                rotate: theta,
                translateX: tx,
                translateY: ty,
                originX: cx,
                originY: cy,

                // Return the matrix parameters
                a: matrix.a,
                b: matrix.b,
                c: matrix.c,
                d: matrix.d,
                e: matrix.e,
                f: matrix.f
            }
        }

        function inverseAndMultiply(matrix1, matrix2) {
            return matrix2.inverse().multiply(matrix1);
        }

        function getMatrix(el) {
            return inverseAndMultiply(
                el.getScreenCTM && el.getScreenCTM() || createSVGMatrix(),
                el.parentNode && el.parentNode.getScreenCTM && el.parentNode.getScreenCTM() || createSVGMatrix()
            );
        }

        function getParentMatrix(element) {

            let node = [];

            parent(element.parentNode);

            function parent(element) {

                if (element.getAttribute('id') && element.getAttribute('id') != 'svgcontent' || !element.getAttribute('id')) {

                    // let transform = SVG(element.outerHTML).transform();
                    // node.push(transform);

                    let matrix = getMatrix(element);

                    // if(element.getAttribute('id') === 'svgGroup'){
                    //     matrix = element.transform.baseVal[0].matrix;
                    // }

                    try {
                        matrix = element.transform.baseVal[0].matrix;
                    } catch { }

                    let transform = decompose(matrix);

                    node.push(transform);

                    if (element.parentNode) {
                        parent(element.parentNode);
                    }

                }
            }

            return node;
        }

        function paths2polygonArrayUpper(path) {
            const polygonArray = [];
            let currentPolygon = [];

            const commands = path.match(/[a-df-zA-DF-Z]|[\-+]?\d+(\.\d+)?([eE][\-+]?\d+)?/g);

            if (!commands) {
                return polygonArray;
            }

            for (let i = 0; i < commands.length; i++) {
                const command = commands[i];
                if (command === 'M') {
                    if (currentPolygon.length > 0) {
                        polygonArray.push(currentPolygon);
                    }
                    currentPolygon = [];
                } else if (!isNaN(parseFloat(command))) {
                    const x = parseFloat(command);
                    const y = parseFloat(commands[i + 1]);

                    currentPolygon.push([Number(x.toFixed(4)), Number(y.toFixed(4))]);

                    i++; // Skip the next value, as it has already been processed.
                }
            }

            if (currentPolygon.length > 0) {
                polygonArray.push(currentPolygon);
            }

            return polygonArray;
        }

        function segmentToPathString(pathData) {
            let d = "";
            for (var s = 0, l = pathData.length; s < l; s += 1) {
                var seg = pathData[s];

                if (s > 0) {
                    d += " ";
                }

                d += seg.type;

                if (seg.values && seg.values.length > 0) {
                    d += " " + seg.values.join(" ");
                }
            }
            return d;
        }

        var base64;
        var base64Data;
        var scene, camera, clock, controls, renderer, width = 0, height = 0, group, boxCenter, width, height, depth;
        var image3d = false;

        const DEG90 = Math.PI * 0.5;
        const DEG180 = Math.PI;

        var options = {
            preset: ''
        };

        const environments = [
            {
                id: '',
                name: 'None',
                path: null,
            },
            {
                id: 'neutral', // THREE.RoomEnvironment
                name: 'Neutral',
                path: null,
            }
        ];

        const Preset = { ASSET_GENERATOR: 'assetgenerator' };

        var lights = [];

        var neutralEnvironment;

        var state = {
            environment: 'None',
            punctualLights: true,
            exposure: 0.0,
            toneMapping: THREE.LinearToneMapping,
            ambientIntensity: 0.3,
            ambientColor: '#FFFFFF',
            directIntensity: 2.5,
            directColor: '#FFFFFF',
            bgColor: '#ffffff',
        }

        var backgroundColor = new THREE.Color(state.bgColor);

        function preview_3D() {

            lights = [];

            width = document.getElementById('model-3d').clientWidth;
            height = document.getElementById('model-3d').clientHeight;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, width / height, 1, 20000);
            scene.add(camera);

            var container = document.getElementById('model-3d');
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            renderer.physicallyCorrectLights = true;
            renderer.outputEncoding = THREE.sRGBEncoding;

            renderer.setClearColor(0xffffff, 1);

            var pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            neutralEnvironment = pmremGenerator.fromScene(new THREE.RoomEnvironment()).texture;

            // renderer.shadowMap.enabled = true;
            // renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default PCFShadowMap

            clock = new THREE.Clock();

            CameraControls.install({
                THREE: THREE
            });

            controls = new CameraControls(camera, renderer.domElement);

            controls.maxDistance = 20000;
            controls.update();

            group = new THREE.Group();

            // สร้างกริด
            const size = 10;
            // const divisions = 100;
            // const gridHelper = new THREE.GridHelper(size, divisions);
            // scene.add(gridHelper);

            // เส้นแกน x (สีแดง)
            const xAxesMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const xAxesGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-size / 2, 0, 0),
                new THREE.Vector3(size / 2, 0, 0)
            ]);
            const xAxesLine = new THREE.Line(xAxesGeometry, xAxesMaterial);
            scene.add(xAxesLine);

            // เส้นแกน y (สีเขียว)
            const yAxesMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const yAxesGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -size / 2, 0),
                new THREE.Vector3(0, size / 2, 0)
            ]);
            const yAxesLine = new THREE.Line(yAxesGeometry, yAxesMaterial);
            scene.add(yAxesLine);

            // เส้นแกน z (สีน้ำเงิน)
            const zAxesMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
            const zAxesGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -size / 2),
                new THREE.Vector3(0, 0, size / 2)
            ]);
            const zAxesLine = new THREE.Line(zAxesGeometry, zAxesMaterial);
            scene.add(zAxesLine);

            scene.add(group);

            const loader = new THREE.GLTFLoader();

            loader.load(window.base64Data, function (gltf) {

                removeCameraAndLight(gltf.scene);

                setShadow(gltf.scene);
                setContent(gltf.scene);

                // gltf.scene.rotation.x = Math.PI / 2;

                // gltf.scene.scale.x = -gltf.scene.scale.x;
                // gltf.scene.scale.y = -gltf.scene.scale.y;
                // gltf.scene.scale.z = gltf.scene.scale.z;


                let model = gltf.scene;

                group.add(model);

                let box = new THREE.Box3().setFromObject(group);
                boxCenter = new THREE.Vector3();
                box.getCenter(boxCenter).multiplyScalar(- 1);

                width = box.max.x - box.min.x;
                height = box.max.y - box.min.y;
                depth = box.max.z - box.min.z;

                group.position.x = boxCenter.x;
                group.position.y = (boxCenter.y > 0 ? (height / 2) + boxCenter.y : -((height / 2) - boxCenter.y) + height);
                group.position.z = boxCenter.z;

                // group.position.z = boxCenter.z - ((width / 2) - 0.165); // door
                // group.position.z = boxCenter.z - ((width / 2) - 0.625); //doble door

                const size = box.getSize(new THREE.Vector3());
                const boundingWidth = size.x;
                const boundingHeight = size.y;

                window.image3dWidth = Math.floor(boundingWidth * 100) + 'cm';
                window.image3dHeight = Math.floor(boundingHeight * 100) + 'cm';

                let dist = Math.sqrt(Math.pow(box.min.x - box.max.x, 2) + Math.pow(box.min.y - box.max.y, 2))

                paddingInCssPixel(group, 0, 0, 0, 0);

                // controls.rotateTo(0, Math.PI * 0.5, false)
                // controls.rotate(- 45 * THREE.MathUtils.DEG2RAD, 0, false)
                // controls.rotate(0, -20 * THREE.MathUtils.DEG2RAD, false)

                controls.rotateTo(0, 0, false)
                // controls.rotate(- 45 * THREE.MathUtils.DEG2RAD, 0, false)
                // controls.rotate(0, -20 * THREE.MathUtils.DEG2RAD, false)

                controls.fitToSphere(group, false)

                renderer.render(scene, camera);

                // save3D();
                saveImage(() => {

                });

            });

            animate();

            window.addEventListener('resize', onWindowResize);
        }

        function setPosittion3D(e) {
            let val = Number(document.getElementById('input3dval').value);
            switch (e) {
                case 'front':
                    controls.rotateTo(0, 90 * THREE.MathUtils.DEG2RAD, true)
                    break;
                case 'back':
                    controls.rotateTo(180 * THREE.MathUtils.DEG2RAD, 90 * THREE.MathUtils.DEG2RAD, true)
                    break;
                case 'left':
                    controls.rotateTo(-90 * THREE.MathUtils.DEG2RAD, 90 * THREE.MathUtils.DEG2RAD, true)
                    break;
                case 'right':
                    controls.rotateTo(90 * THREE.MathUtils.DEG2RAD, 90 * THREE.MathUtils.DEG2RAD, true)
                    break;
                case 'top':
                    controls.rotateTo(0, 0, true)
                    break;
                case 'bottom':
                    controls.rotateTo(0, 180 * THREE.MathUtils.DEG2RAD, true)
                    break;
                case '-x':
                    group.position.x -= val;
                    break;
                case '+x':
                    group.position.x += val;
                    break;
                case '-y':
                    group.position.y -= val;
                    break;
                case '+y':
                    group.position.y += val;
                    break;
                case '-z':
                    group.position.z -= val;
                    break;
                case '+z':
                    group.position.z += val;
                    break;
                case 'rotate_x':
                    group.rotation.x += Math.PI / 2;
                    if (group.rotation.x >= Math.PI * 2) {
                        group.rotation.x -= Math.PI * 2;
                    }
                    break;
                case 'rotate_y':
                    group.rotation.y += Math.PI / 2;
                    if (group.rotation.y >= Math.PI * 2) {
                        group.rotation.y -= Math.PI * 2;
                    }
                    break;
                case 'rotate_z':
                    group.rotation.z += Math.PI / 2;
                    if (group.rotation.z >= Math.PI * 2) {
                        group.rotation.z -= Math.PI * 2;
                    }
                    break;
                case 'flip_x':
                    group.scale.x = (group.scale.x > 0 ? -Math.abs(group.scale.x) : Math.abs(group.scale.x));
                    break;
                case 'flip_y':
                    group.scale.y = (group.scale.y > 0 ? -Math.abs(group.scale.y) : Math.abs(group.scale.y));
                    break;
                case 'flip_z':
                    group.scale.z = (group.scale.z > 0 ? -Math.abs(group.scale.z) : Math.abs(group.scale.z));
                    break;
            }
            renderer.render(scene, camera);
        }

        function save3D(callback) {
            saveImage(function () {
                const exporter = new THREE.GLTFExporter();
                let clone = scene.clone(true);
                removeCameraAndLight(clone);
                exporter.parseAsync(clone, { binary: true }).then((buffer) => {
                    const binaryData = [];
                    const bytes = new Uint8Array(buffer);
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binaryData.push(String.fromCharCode(bytes[i]));
                    }
                    const base64String = btoa(binaryData.join(''));
                    window.base64 = base64String;
                    callback();
                });
            });
        }

        function saveImage(callback) {
            setTimeout(() => {

                let line = [];

                scene.traverse(function (object) {
                    if (object instanceof THREE.Line) {
                        object.visible = false;
                        line.push(object)
                        renderer.render(scene, camera);
                    }
                });

                const dataURL = renderer.domElement.toDataURL("image/png");
                image3d = dataURL.split(',')[1];
                document.getElementById('btn-save-preview').disabled = false;

                for (let i in line) {
                    line[i].visible = true;
                }
                renderer.render(scene, camera);

                callback();

            }, 1000);
        }

        function setShadow(model) {

            model.traverse(function (child) {
                if (child instanceof THREE.Mesh) {
                    child.material.receiveShadow = true; // รับแสงเงา
                    child.material.castShadow = true; // ส่งแสงเงา
                }
            });
        }

        function setContent(object) {

            state.punctualLights = true;

            object.traverse((node) => {
                if (node.isLight) {
                    state.punctualLights = false;
                }
            });

            updateLights();
            updateEnvironment();
        }

        function updateLights() {
            if (state.punctualLights && !lights.length) {
                addLights();
            } else if (!state.punctualLights && lights.length) {
                removeLights();
            }

            renderer.toneMapping = Number(state.toneMapping);
            renderer.toneMappingExposure = Math.pow(2, state.exposure);

            if (lights.length === 2) {
                lights[0].intensity = state.ambientIntensity;
                lights[0].color.set(state.ambientColor);
                lights[1].intensity = state.directIntensity;
                lights[1].color.set(state.directColor);
            }

            renderer.render(scene, camera);
        }

        function updateEnvironment() {

            var environment = environments.filter((entry) => entry.name === state.environment)[0];

            getCubeMapTexture(environment).then(({ envMap }) => {
                scene.environment = envMap;
                scene.background = state.background ? envMap : backgroundColor;
                renderer.render(scene, camera);
            });

        }

        function getCubeMapTexture(environment) {

            const { id, path } = environment;

            // neutral (THREE.RoomEnvironment)
            if (id === 'neutral') {
                return Promise.resolve({ envMap: neutralEnvironment });
            }

            // none
            if (id === '') {
                return Promise.resolve({ envMap: null });
            }

            return new Promise((resolve, reject) => {
                new THREE.EXRLoader().load(
                    path,
                    (texture) => {
                        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                        pmremGenerator.dispose();

                        renderer.render(scene, camera);

                        resolve({ envMap });

                    },
                    undefined,
                    reject,
                );
            });

        }

        function removeCameraAndLight(model) {

            let camerasToRemove = [];
            let lightsToRemove = [];
            let lineToRemove = [];

            model.traverse(function (object) {
                if (object instanceof THREE.Camera) {
                    camerasToRemove.push(object);
                } else if (object instanceof THREE.Light) {
                    lightsToRemove.push(object);
                } else if (object instanceof THREE.Line) {
                    lineToRemove.push(object);
                }
            });

            for (let i = 0; i < camerasToRemove.length; i++) {
                camerasToRemove[i].parent.remove(camerasToRemove[i]);
            }

            for (let i = 0; i < lightsToRemove.length; i++) {
                lightsToRemove[i].parent.remove(lightsToRemove[i]);
            }

            for (let i = 0; i < lineToRemove.length; i++) {
                lineToRemove[i].parent.remove(lineToRemove[i]);
            }

        }

        function addLights() {

            const light1 = new THREE.AmbientLight(state.ambientColor, state.ambientIntensity);
            light1.name = 'ambient_light';
            camera.add(light1);

            const light2 = new THREE.DirectionalLight(state.directColor, state.directIntensity);
            light2.position.set(1, 1, 1); // ~60º
            light2.name = 'main_light';
            camera.add(light2);

            lights.push(light1, light2);
        }

        function removeLights() {
            lights.forEach((light) => light.parent.remove(light));
            lights.length = 0;
        }

        function paddingInCssPixel(mesh, top, right, bottom, left) {

            const fov = camera.fov * THREE.MathUtils.DEG2RAD;
            const rendererHeight = renderer.getSize(new THREE.Vector2()).height;

            const boundingBox = new THREE.Box3().setFromObject(mesh);
            const size = boundingBox.getSize(new THREE.Vector3());
            const boundingWidth = size.x;
            const boundingHeight = size.y;
            const boundingDepth = size.z;

            var distanceToFit = controls.getDistanceToFitBox(boundingWidth, boundingHeight, boundingDepth);
            var paddingTop = 0;
            var paddingBottom = 0;
            var paddingLeft = 0;
            var paddingRight = 0;

            // loop to find almost convergence points
            for (var i = 0; i < 10; i++) {

                const depthAt = distanceToFit - boundingDepth * 0.5;
                const cssPixelToUnit = (2 * Math.tan(fov * 0.5) * Math.abs(depthAt)) / rendererHeight;
                paddingTop = top * cssPixelToUnit;
                paddingBottom = bottom * cssPixelToUnit;
                paddingLeft = left * cssPixelToUnit;
                paddingRight = right * cssPixelToUnit;

                distanceToFit = controls.getDistanceToFitBox(
                    boundingWidth + paddingLeft + paddingRight,
                    boundingHeight + paddingTop + paddingBottom,
                    boundingDepth
                );

            }

            controls.fitToBox(mesh, false, { paddingLeft: paddingLeft, paddingRight: paddingRight, paddingBottom: paddingBottom, paddingTop: paddingTop });

        }

        function rotateTo(side) {

            switch (side) {

                case 'front':
                    controls.rotateTo(0, DEG90, true);
                    break;

                case 'back':
                    controls.rotateTo(DEG180, DEG90, true);
                    break;

                case 'up':
                    controls.rotateTo(0, 0, true);
                    break;

                case 'down':
                    controls.rotateTo(0, DEG180, true);
                    break;

                case 'right':
                    controls.rotateTo(DEG90, DEG90, true);
                    break;

                case 'left':
                    controls.rotateTo(- DEG90, DEG90, true);
                    break;

            }

        }

        function animate() {

            const delta = clock.getDelta();
            const hasControlsUpdated = controls.update(delta);

            requestAnimationFrame(animate);

            if (hasControlsUpdated) {
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);

        }

    </script>
</body>

</html>